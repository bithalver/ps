% Copyright (c) 1990-1994 Adobe Systems
Incorporated.
% All Rights Reserved.
% This code to be used for Flex and hint replacement.
% Version 11

/shareddict where
{ pop currentshared { setshared } true setshared
shareddict }
{ {} userdict } ifelse dup
/makeblendedfont where {/makeblendedfont get dup
type /operatortype eq {
pop false} { 0 get dup type /integertype ne
{pop false} {11 lt} ifelse} ifelse } {true}ifelse
{/makeblendedfont {
11 pop
2 copy length exch /WeightVector get length eq
{ dup 0 exch {add} forall 1 sub abs .001 gt }
{ true } ifelse
{ /makeblendedfont cvx errordict /rangecheck get
exec } if
exch dup dup maxlength dict begin {
false {/FID /UniqueID /XUID } { 3 index eq or } forall
{ pop pop } { def } ifelse
} forall
/XUID 2 copy known{
get dup length 2 index length sub dup 0 gt{
exch dup length array copy
exch 2 index{65536 mul cvi 3 copy put pop 1
add}forall pop/XUID exch def
}{pop pop}ifelse
}{pop pop}ifelse
{ /Private /FontInfo } {
dup load dup maxlength dict begin {
false { /UniqueID /XUID } { 3 index eq or } forall
{ pop pop }{ def } ifelse } forall currentdict end def
} forall
dup /WeightVector exch def
dup /$Blend exch [
exch false exch
dup length 1 sub -1 1 {
1 index dup length 3 -1 roll sub get
dup 0 eq {
pop 1 index {/exch load 3 1 roll} if
/pop load 3 1 roll
} {dup 1 eq {pop}
{2 index {/exch load 4 1 roll} if
3 1 roll /mul load 3 1 roll } ifelse
1 index {/add load 3 1 roll} if
exch pop true exch} ifelse
} for
pop { /add load } if
] cvx def
{2 copy length exch length ne {/makeblendedfont cvx
errordict /typecheck get exec}if
0 0 1 3 index length 1 sub {
dup 4 index exch get exch 3 index exch get mul add
} for
exch pop exch pop}
{{dup type dup dup /arraytype eq exch
/packedarraytype eq or {
pop 1 index /ForceBold eq {
5 index 0 0 1 3 index length 1 sub {
dup 4 index exch get {2 index exch get add } {pop}
ifelse
} for exch pop exch pop
2 index /ForceBoldThreshold get gt 3 copy} {
{length 1 index length ne { pop false } {
true exch { type dup /integertype eq exch /realtype eq
exch or and } forall
} ifelse }
2 copy 8 index exch exec {pop 5 index 5 index exec}
{exch dup length array 1 index xcheck { cvx } if
dup length 1 sub 0 exch 1 exch {
dup 3 index exch get dup type dup /arraytype eq exch
/packedarraytype eq or {
dup 10 index 6 index exec {
9 index exch 9 index exec} if } if 2 index 3 1 roll put
} for exch pop exch pop
} ifelse 3 copy
1 index dup /StemSnapH eq exch /StemSnapV eq or {
dup length 1 sub {dup 0 le { exit } if
dup dup 1 sub 3 index exch get exch 3 index exch get 2
copy eq {
pop 2 index 2 index 0 put 0 } if le {1 sub}
{dup dup 1 sub 3 index exch get exch 3 index exch get
3 index exch 3 index 1 sub exch put
3 copy put pop
2 copy exch length 1 sub lt {1 add} if} ifelse} loop pop
dup 0 get 0 le {
dup 0 exch {0 gt { exit } if 1 add} forall
dup 2 index length exch sub getinterval} if } if } ifelse
put }
{/dicttype eq {6 copy 3 1 roll get exch 2 index exec}
{/makeblendedfont cvx errordict /typecheck get exec}
ifelse
} ifelse pop pop } forall pop pop pop pop }
currentdict Blend 2 index exec
currentdict end
} bind put
/$fbf {FontDirectory counttomark 3 add -1 roll
known {
cleartomark pop findfont}{
] exch findfont exch makeblendedfont
dup /Encoding currentfont /Encoding get put
definefont
} ifelse currentfont /ScaleMatrix get makefont setfont
} bind put } { pop pop } ifelse exec
